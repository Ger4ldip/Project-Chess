from os import remove
from time import perf_counter
from math import ceil
result = '*'
move_number = 1
move_turn = 1
moves50 = 0
cast = [2, -3, 2, -3]
enpassant = []
fen = ''
start_fen = ''
depth = 3  # set - default, for test use max 10
reached_depth = 0
Board = [[], [], [], [], [], [], [], []]
for i in range(8):
    Board[i] = ['.', '.', '.', '.', '.', '.', '.', '.']
filename = ["first.txt", "second.txt"]


def castle(color):
    global cast
    take_moves = simple_moves(1 - color)
    castle_possibility = []

    if Board[7][4] == '.' or Board[7][4].__str__() != 'K':
        cast[0] = 0
        cast[1] = 0

    if cast[0] != 0 and (Board[7][7] == '.' or Board[7][7].__str__() != 'R'):
        cast[0] = 0
    if cast[1] != 0 and (Board[7][0] == '.' or Board[7][0].__str__() != 'R'):
        cast[1] = 0

    if Board[0][4] == '.' or Board[0][4].__str__() != 'k':
        cast[2] = 0
        cast[3] = 0

    if cast[2] != 0 and (Board[0][7] == '.' or Board[0][7].__str__() != 'r'):
        cast[2] = 0
    if cast[3] != 0 and (Board[0][0] == '.' or Board[0][0].__str__() != 'r'):
        cast[3] = 0

    if cast[(1 - color) * 2] != 0 and Board[color * 7][5] == '.' and [color * 7, 5] not in take_moves and \
            Board[color * 7][6] == '.' and [color * 7, 6] not in take_moves:
        castle_possibility.append('short_castle')
    if cast[(1 - color) * 2 + 1] != 0 and Board[color * 7][3] == '.' and [color * 7, 3] not in take_moves and \
            Board[color * 7][2] == '.' and [color * 7, 2] not in take_moves and Board[color * 7][1] == '.' and [
        color * 7, 1] not in take_moves:
        castle_possibility.append('long_castle')

    return castle_possibility


def simple_moves(color):
    moves = []
    a = 0
    b = 0
    while a < 8:
        while b < 8:
            if Board[a][b] != '.' and Board[a][b].color == color and Board[a][b].moves() != []:
                moves += Board[a][b].moves()
            for j in range(len(moves)):
                if len(moves[j]) == 3:
                    moves[j].pop(2)
            b += 1
        b = 0
        a += 1
    return moves


def color_moves(color):
    moves = []
    a = 0
    b = 0
    while a < 8:
        while b < 8:
            if Board[a][b] != '.' and Board[a][b].color == color and Board[a][b].moves() != []:
                oxt = [a, b]
                lst = Board[a][b].moves()
                for j in range(len(lst)):
                    if (len(lst[j])) == 3:
                        oxt += (lst[j][0], lst[j][1], lst[j][2])
                    else:
                        oxt += (lst[j][0], lst[j][1])
                moves.append(oxt)
            b += 1
        b = 0
        a += 1
    return moves


def check(color):
    king_coord = []
    opposite_king_coord = []
    is_check = 0
    for a in range(8):
        for b in range(8):
            if Board[a][b] != '.' and Board[a][b].__str__() == chr(ord('K') + 32 * (1 - color)):
                king_coord = [a, b]
            if Board[a][b] != '.' and Board[a][b].__str__() == chr(ord('K') + 32 * color):
                opposite_king_coord = [a, b]
    moves = color_moves(1 - color)
    if abs(opposite_king_coord[1] - king_coord[1]) == 1 and abs(opposite_king_coord[0] - king_coord[0]) == 0:
        is_check = 1
        return is_check
    if abs(opposite_king_coord[1] - king_coord[1]) == 0 and abs(opposite_king_coord[0] - king_coord[0]) == 1:
        is_check = 1
        return is_check
    if abs(opposite_king_coord[1] - king_coord[1]) == 1 and abs(opposite_king_coord[0] - king_coord[0]) == 1:
        is_check = 1
        return is_check
    for h in range(len(moves)):
        j = 2
        if len(moves[h]) >= 5 and str(type(moves[h][4])) == "<class 'str'>":
            k = len(moves[h]) - 1
            while k >= 4:
                moves[h].pop(k)
                k -= 3
        while j < len(moves[h]):
            mas = [moves[h][j], moves[h][j + 1]]
            # print(mas, king_coord)
            if mas == king_coord:
                is_check = 1
                break
            j += 2
    return is_check


def possible_move(color):
    moves = []
    massiv = color_moves(color)
    for d in range(len(massiv)):
        if len(massiv[d]) >= 5 and str(type(massiv[d][4])) == "<class 'str'>":
            for k in range((len(massiv[d]) - 2) // 12):
                if len(massiv[d][4 + k * 12]) <= 8:
                    Board[massiv[d][0]][massiv[d][1]] = '.'
                    Board[massiv[d][2]][massiv[d][3]] = Pawn(color, massiv[d][2], massiv[d][3])
                    if check(color) == 0:
                        for g in range(4):
                            moves.append([massiv[d][0], massiv[d][1], massiv[d][2], massiv[d][3], massiv[d][4 + g * 3]])
                    Board[massiv[d][2]][massiv[d][3]] = '.'
                    Board[massiv[d][0]][massiv[d][1]] = Pawn(color, massiv[d][0], massiv[d][1])
                else:
                    piece = Board[massiv[d][2 + k * 12]][massiv[d][3 + k * 12]]
                    Board[massiv[d][0]][massiv[d][1]] = '.'
                    Board[massiv[d][2 + k * 12]][massiv[d][3 + k * 12]] = Pawn(color, massiv[d][2 + k * 12],
                                                                               massiv[d][3 + k * 12])
                    if check(color) == 0:
                        for g in range(4):
                            moves.append([massiv[d][0], massiv[d][1], massiv[d][k * 12 + 2], massiv[d][k * 12 + 3],
                                          massiv[d][k * 12 + 4 + g * 3]])
                    Board[massiv[d][2 + k * 12]][massiv[d][3 + k * 12]] = piece
                    Board[massiv[d][0]][massiv[d][1]] = Pawn(color, massiv[d][0], massiv[d][1])
        else:
            j = 2
            while j < (len(massiv[d])):
                moven = [massiv[d][0], massiv[d][1], massiv[d][j], massiv[d][j + 1]]
                piece = Board[moven[2]][moven[3]]
                Board[moven[2]][moven[3]] = Board[moven[0]][moven[1]]
                Board[moven[0]][moven[1]] = '.'
                Board[moven[2]][moven[3]].x = moven[2]
                Board[moven[2]][moven[3]].y = moven[3]
                if check(color) == 0:
                    moves.append(moven)
                j += 2
                Board[moven[0]][moven[1]] = Board[moven[2]][moven[3]]
                Board[moven[2]][moven[3]] = piece
                Board[moven[0]][moven[1]].x = moven[0]
                Board[moven[0]][moven[1]].y = moven[1]
    return moves


class Piece(object):
    IMG = None

    def __init__(self, color, x, y):
        self.color = color
        self.x = x
        self.y = y

    def __str__(self):
        return self.IMG[0 if self.color == 0 else 1]


class Pawn(Piece):
    IMG = ('p', 'P')

    def moves(self):
        just_promotion = [[(1 - self.color) * 7, self.y, str(self.x) + str(self.y) + "knight"],
                          [(1 - self.color) * 7, self.y, str(self.x) + str(self.y) + "bishop"],
                          [(1 - self.color) * 7, self.y, str(self.x) + str(self.y) + "rook"],
                          [(1 - self.color) * 7, self.y, str(self.x) + str(self.y) + "queen"]]
        plus_promotion = [[(1 - self.color) * 7, self.y + 1, str(self.x) + str(self.y) + "take_+1_knight"],
                          [(1 - self.color) * 7, self.y + 1, str(self.x) + str(self.y) + "take_+1_bishop"],
                          [(1 - self.color) * 7, self.y + 1, str(self.x) + str(self.y) + "take_+1_rook"],
                          [(1 - self.color) * 7, self.y + 1, str(self.x) + str(self.y) + "take_+1_queen"]]
        minus_promotion = [[(1 - self.color) * 7, self.y - 1, str(self.x) + str(self.y) + "take_-1_knight"],
                           [(1 - self.color) * 7, self.y - 1, str(self.x) + str(self.y) + "take_-1_bishop"],
                           [(1 - self.color) * 7, self.y - 1, str(self.x) + str(self.y) + "take_-1_rook"],
                           [(1 - self.color) * 7, self.y - 1, str(self.x) + str(self.y) + "take_-1_queen"]]
        moves = []
        cells = [1, -1]
        a = (-self.color) * 2 + 1
        b = (1 - self.color) * 5 + 1
        if self.color + 1 <= self.x <= self.color + 5 and Board[self.x + a][self.y] == '.':
            moves.append([self.x + a, self.y])
            if self.x == self.color * 5 + 1 and Board[self.x + a * 2][self.y] == '.':
                moves.append([self.x + a * 2, self.y])
        if self.x == b and Board[self.x + a][self.y] == '.':
            moves += just_promotion
        for j in range(len(cells)):
            if self.color + 1 <= self.x <= self.color + 5 and 0 < self.y + cells[j] < 7 and Board[self.x + a][
                self.y + cells[j]] != '.' and abs(self.color - Board[self.x + a][self.y + cells[j]].color) == 1:
                moves.append([self.x + a, self.y + cells[j]])
            if self.x == b and 0 < self.y + cells[j] < 7 and Board[self.x + a][self.y + cells[j]] != '.' and abs(
                    self.color - Board[self.x + a][self.y + cells[j]].color) == 1:
                if cells[j] == 1:
                    moves += plus_promotion
                else:
                    moves += minus_promotion
        return moves


class Knight(Piece):
    IMG = ('n', 'N')

    def take_move(self, xnew, ynew):
        lst = []
        if 0 <= xnew <= 7 and 0 <= ynew <= 7:
            if Board[xnew][ynew] == '.':
                lst.append([xnew, ynew])
            elif abs(self.color - Board[xnew][ynew].color) == 1:
                lst.append([xnew, ynew])
        return lst

    def moves(self):
        moves = []
        cells = [[-1, -2], [-2, -1], [-2, 1], [-1, 2], [1, 2], [2, 1], [2, -1], [1, -2]]
        for j in range(len(cells)):
            moves += Knight.take_move(self, self.x + cells[j][0], self.y + cells[j][1])
        return moves


class Bishop(Piece):
    IMG = ('b', 'B')

    def take_moves(self, p, j):
        lst = []
        xnew = self.x + p
        ynew = self.y + j
        while 0 <= xnew <= 7 and 0 <= ynew <= 7:
            if Board[xnew][ynew] == '.':
                lst.append([xnew, ynew])
                xnew += p
                ynew += j
            else:
                if abs(self.color - Board[xnew][ynew].color) == 1:
                    lst.append([xnew, ynew])
                break
        return lst

    def moves(self):
        moves = []
        cells = [[1, 1], [1, -1], [-1, 1], [-1, -1]]
        for j in range(len(cells)):
            moves += Bishop.take_moves(self, cells[j][0], cells[j][1])
        return moves


class Rook(Piece):
    IMG = ('r', 'R')

    def take_moves(self, g, j):
        lst = []
        xnew = self.x + g
        ynew = self.y + j
        while 0 <= xnew <= 7 and 0 <= ynew <= 7:
            if Board[xnew][ynew] == '.':
                lst.append([xnew, ynew])
                xnew += g
                ynew += j
            else:
                if abs(self.color - Board[xnew][ynew].color) == 1:
                    lst.append([xnew, ynew])
                break
        return lst

    def moves(self):
        moves = []
        cells = [[1, 0], [-1, 0], [0, 1], [0, -1]]
        for j in range(len(cells)):
            moves += Rook.take_moves(self, cells[j][0], cells[j][1])
        return moves


class Queen(Piece):
    IMG = ('q', 'Q')

    def moves(self):
        moves = []
        moves += Rook(self.color, self.x, self.y).moves()
        moves += Bishop(self.color, self.x, self.y).moves()
        return moves


class King(Piece):
    IMG = ('k', 'K')

    def take_move(self, xnew, ynew):
        lst = []
        if 0 <= xnew <= 7 and 0 <= ynew <= 7 and Board[xnew][ynew] == '.':
            lst.append([xnew, ynew])
        if 0 <= xnew <= 7 and 0 <= ynew <= 7 and Board[xnew][ynew] == '.' and Board[xnew][ynew] != '.' and abs(
                Board[xnew][ynew].color - self.color) == 1:
            lst.append([xnew, ynew])
        return lst

    def moves(self):
        king_cells = [[-1, -1], [0, -1], [1, -1], [1, 0], [1, 1], [0, 1], [-1, 1], [-1, 0]]
        moves = []
        for j in range(len(king_cells)):
            moves += King.take_move(self, self.x + king_cells[j][0], self.y + king_cells[j][1])
        return moves


def print_board():
    printboard = ''
    for y in range(8):
        printboard += ''.join(map(str, Board[y])) + "\n"
        # FEN += ''.join(map(str, Board[y])) + "/"
    return printboard


def print_move(moven):
    letter = Board[moven[2]][moven[3]].__str__()
    if letter in ['p', 'P']:
        letter = ''
    if letter in ['k', 'K']:
        letter = 'K'
    if letter in ['n', 'N']:
        letter = 'N'
    if letter in ['b', 'B']:
        letter = 'B'
    if letter in ['q', 'Q']:
        letter = 'Q'
    if letter in ['r', 'R']:
        letter = 'R'
    printing = str(letter) + str(chr(ord('a') + moven[3])) + str(8 - moven[2]) + ' '
    return printing


def do_move(moven):
    Board[moven[2]][moven[3]] = Board[moven[0]][moven[1]]
    Board[moven[2]][moven[3]].x = moven[2]
    Board[moven[2]][moven[3]].y = moven[3]
    Board[moven[0]][moven[1]] = '.'


def promotion(color, typ):
    typ = typ[4]
    if len(typ) <= 8:
        ynew = int(typ[1])
        piece = typ[2:]
    else:
        piece = typ[10:]
        if typ[7] == "-":
            ynew = int(typ[1]) - 1
        else:
            ynew = int(typ[1]) + 1
    Board[int(typ[0])][int(typ[1])] = '.'
    Board[7 - 7 * color][ynew] = '.'
    yn = str(chr(ord('a') + ynew)) + str(8 - 7 + 7 * color)
    if piece == "knight":
        Board[7 - 7 * color][ynew] = Knight(color, 7 - 7 * color, ynew)
        return yn + "=N"
    if piece == "bishop":
        Board[7 - 7 * color][ynew] = Bishop(color, 7 - 7 * color, ynew)
        return yn + "=B"
    if piece == "rook":
        Board[7 - 7 * color][ynew] = Rook(color, 7 - 7 * color, ynew)
        return yn + "=R"
    if piece == "queen":
        Board[7 - 7 * color][ynew] = Queen(color, 7 - 7 * color, ynew)
        return yn + "=Q"


def castle_move(color, typo):
    vert = color * 7
    if typo == 'short_castle':
        Board[vert][6] = Board[vert][4]
        Board[vert][6].x = vert
        Board[vert][6].y = 6
        Board[vert][4] = '.'
        Board[vert][5] = Board[vert][7]
        Board[vert][5].x = vert
        Board[vert][5].y = 5
        Board[vert][7] = '.'
    if typo == 'long_castle':
        Board[vert][2] = Board[vert][4]
        Board[vert][2].x = vert
        Board[vert][2].y = 2
        Board[vert][4] = '.'
        Board[vert][3] = Board[vert][0]
        Board[vert][3].x = vert
        Board[vert][3].y = 3
        Board[vert][0] = '.'


def game_result(moven):
    flag = 0
    global moves50, result
    if Board[moven[0]][moven[1]].__str__() not in ['p', 'P']:
        moves50 += 1
        flag = 1
    else:
        moves50 = 0
    if Board[moven[2]][moven[3]] not in ['p', 'P', 'q', 'Q', 'k', 'K', 'n', 'N', 'b', 'B', 'r', 'R']:
        if flag != 1:
            moves50 += 1
    else:
        moves50 = 0
    if moves50 == 101:
        result = '1/2-1/2'


def mate(moves):
    global result, move_turn
    if moves == [] and check(move_turn) == 0:
        result = '1/2-1/2'
    if moves == [] and check(move_turn) == 1:
        if move_turn == 1:
            result = '0-1'
        else:
            result = '1-0'


def fen_get():
    global fen, move_turn, cast, moves50, move_number, Board
    # print("HERE")
    Board = [[], [], [], [], [], [], [], []]
    for y in range(8):
        Board[y] = ['.', '.', '.', '.', '.', '.', '.', '.']
    amount_of_slash = 0
    j = 0
    x = 0
    y = 0
    fir = 0
    while j < len(fen):
        if 49 <= ord(fen[j]) <= 56:
            y += int(fen[j])
        if fen[j] == 'r':
            Board[x][y] = Rook(0, x, y)
            y += 1
        if fen[j] == 'R':
            Board[x][y] = Rook(1, x, y)
            y += 1
        if fen[j] == 'k' and amount_of_slash < 8:
            Board[x][y] = King(0, x, y)
            y += 1
        if fen[j] == 'K' and amount_of_slash < 8:
            Board[x][y] = King(1, x, y)
            y += 1
        if fen[j] == 'b' and amount_of_slash < 8:
            Board[x][y] = Bishop(0, x, y)
            y += 1
        if fen[j] == 'B':
            Board[x][y] = Bishop(1, x, y)
            y += 1
        if fen[j] == 'p':
            Board[x][y] = Pawn(0, x, y)
            y += 1
        if fen[j] == 'P':
            Board[x][y] = Pawn(1, x, y)
            y += 1
        if fen[j] == 'q' and amount_of_slash < 8:
            Board[x][y] = Queen(0, x, y)
            y += 1
        if fen[j] == 'Q' and amount_of_slash < 8:
            Board[x][y] = Queen(1, x, y)
            y += 1
        if fen[j] == 'n':
            Board[x][y] = Knight(0, x, y)
            y += 1
        if fen[j] == 'N':
            Board[x][y] = Knight(1, x, y)
            y += 1
        if fen[j] == '/':
            x += 1
            y = 0
            amount_of_slash += 1
        # взятия на проходе
        if fen[j] == ' ':
            amount_of_slash += 1
        if fen[j] == 'w':
            move_turn = 1
        if fen[j] == 'b' and amount_of_slash >= 8:
            move_turn = 0
        if amount_of_slash >= 8 and fen[j] == 'K':
            cast[0] = 2
        if amount_of_slash >= 8 and fen[j] == 'Q':
            cast[1] = -3
        if amount_of_slash >= 8 and fen[j] == 'k':
            cast[2] = 2
        if amount_of_slash >= 8 and fen[j] == 'q':
            cast[3] = -3
        if amount_of_slash >= 8 and 48 <= ord(fen[j]) <= 57 and fir == 0:
            st = fen[j]
            while 48 <= ord(fen[j]) <= 57 and j < len(fen) - 1:
                j += 1
                st += fen[j]
            moves50 = int(st)
            fir = 1
        if amount_of_slash >= 8 and 48 <= ord(fen[j]) <= 57 and fir == 1:
            st = fen[j]
            while 48 <= ord(fen[j]) <= 57 and j < len(fen) - 1:
                j += 1
                st += fen[j]
            move_number = int(st)
        j += 1


def en_passant(moven, color):
    color = 1 - color
    enpas = []
    if Board[moven[0]][moven[1]].__str__() not in ['p', 'P']:
        return 0
    if abs(moven[2] - moven[0]) != 2:
        return 0
    a = -2 * color + 1
    if moven[3] != 7:
        if Board[moven[2]][moven[3] + 1] != '.' and Board[moven[2]][moven[3] + 1].__str__() in ['P', 'p'] and \
                Board[moven[2]][moven[3] + 1].color == color:
            strings = "en_passant" + str(moven[2]) + str(moven[3])
            lst = [moven[2], moven[3] + 1, moven[2] + a, moven[3], strings]
            enpas.append(lst)
    if moven[3] != 0:
        if Board[moven[2]][moven[3] - 1] != '.' and Board[moven[2]][moven[3] - 1].__str__() in ['P', 'p'] and \
                Board[moven[2]][moven[3] - 1].color == color:
            strings = "en_passant" + str(moven[2]) + str(moven[3])
            lst = [moven[2], moven[3] - 1, moven[2] + a, moven[3], strings]
            enpas.append(lst)
    if len(enpas) != 0:
        return enpas
    else:
        return 0


def do_enpassant(moven):
    s = moven[4][10:]
    x = int(s[0])
    y = int(s[1])
    do_move(moven)
    Board[x][y] = '.'


def check_en_passant(mover, color):
    s = mover[4][10:]
    x = int(s[0])
    y = int(s[1])
    Board[mover[2]][mover[3]] = Board[mover[0]][mover[1]]
    Board[mover[2]][mover[3]].x = mover[2]
    Board[mover[2]][mover[3]].y = mover[3]
    Board[mover[0]][mover[1]] = '.'
    Board[x][y] = '.'
    if check(color) == 0:
        Board[x][y] = Pawn(1 - color, x, y)
        Board[mover[0]][mover[1]] = Board[mover[2]][mover[3]]
        Board[mover[0]][mover[1]].x = mover[0]
        Board[mover[0]][mover[1]].y = mover[1]
        Board[mover[2]][mover[3]] = '.'
        return 0
    else:
        Board[x][y] = Pawn(1 - color, x, y)
        Board[mover[0]][mover[1]] = Board[mover[2]][mover[3]]
        Board[mover[0]][mover[1]].x = mover[0]
        Board[mover[0]][mover[1]].y = mover[1]
        Board[mover[2]][mover[3]] = '.'
        return 1


def all_moves(fenget):
    # ЗДЕСЬ FENGET, так как сюда мы будем посылать позицию
    global fen, move_turn
    fen = fenget
    cur_moves = []
    if result == '*':
        mate(possible_move(move_turn))
        if result != '*':
            return 0
        cur_moves = possible_move(move_turn)
        cur_moves += castle(move_turn)
        if len(enpassant) != 0:
            for y in range(len(enpassant)):
                if check_en_passant(enpassant[y], move_turn) == 0:
                    cur_moves.append(enpassant[y])
    return cur_moves


def move_decision(move):
    global moves50, move_turn, cast

    if move_turn == 1:
        move_turn = 0
    else:
        move_turn = 1

    if str(type(move)) == "<class 'list'>" and len(move) == 4:  # УО - 1
        if Board[move[0]][move[1]].__str__() not in ["p", "P"]:
            moves50 += 1
        else:
            moves50 = 0
        do_move(move)
        castle(1 - move_turn)
        return uci_move(1, move)

    if str(type(move)) == "<class 'str'>":  # УО - 2
        castle_move(1 - move_turn, move)
        moves50 += 1
        castle(1 - move_turn)
        return uci_move(2, move)

    if move[4][:10] == "en_passant":  # УО - 3
        do_enpassant(move)
        moves50 = 0
        castle(1 - move_turn)
        return uci_move(3, move)
    else:
        moves50 = 0  # УО - 4
        castle(1 - move_turn)
        return uci_move(4, promotion(1 - move_turn, move))


def enumeration():
    global start_fen, move_turn, fen
    moves = all_moves(fen)
    sequence = []
    for k in range(len(moves)):
        sequence.append([move_decision(moves[k]), fen_code(), evaluation()])
        fen_get()
    return sequence


def evaluation():
    pawn_value = 100
    bishop_value = 320
    knight_value = 300
    rook_value = 500
    queen_value = 900
    king_value = 30000
    black = 0
    white = 0
    for k in range(8):
        for p in range(8):
            if Board[k][p] != '.':
                if Board[k][p].__str__() == 'p':
                    black += pawn_value
                if Board[k][p].__str__() == 'n':
                    black += knight_value
                if Board[k][p].__str__() == 'b':
                    black += bishop_value
                if Board[k][p].__str__() == 'r':
                    black += rook_value
                if Board[k][p].__str__() == 'q':
                    black += queen_value
                if Board[k][p].__str__() == 'k':
                    black += king_value
                if Board[k][p].__str__() == 'P':
                    white += pawn_value
                if Board[k][p].__str__() == 'N':
                    white += knight_value
                if Board[k][p].__str__() == 'B':
                    white += bishop_value
                if Board[k][p].__str__() == 'R':
                    white += rook_value
                if Board[k][p].__str__() == 'Q':
                    white += queen_value
                if Board[k][p].__str__() == 'K':
                    white += king_value
    evalu = (white - black) / 100
    if evalu > 0:
        evalu = "+" + str(evalu)
    else:
        evalu = str(evalu)
    return evalu


def fen_code():
    global moves50, move_turn, move_number, cast, enpassant  # добавить взятия на проходе
    empt = 0
    fen_ret = ''
    for k in range(8):
        for v in range(8):
            if Board[k][v] == '.':
                empt += 1
            if empt != 0:
                if v < 7:
                    if Board[k][v + 1] != '.':
                        fen_ret += str(empt)
                        empt = 0
                else:
                    fen_ret += str(empt)
                    empt = 0
            if Board[k][v].__str__() == 'p':
                fen_ret += 'p'
                empt = 0
            if Board[k][v].__str__() == 'P':
                fen_ret += 'P'
                empt = 0
            if Board[k][v].__str__() == 'k':
                fen_ret += 'k'
                empt = 0
            if Board[k][v].__str__() == 'K':
                fen_ret += 'K'
                empt = 0
            if Board[k][v].__str__() == 'n':
                fen_ret += 'n'
                empt = 0
            if Board[k][v].__str__() == 'N':
                fen_ret += 'N'
                empt = 0
            if Board[k][v].__str__() == 'b':
                fen_ret += 'b'
                empt = 0
            if Board[k][v].__str__() == 'B':
                fen_ret += 'B'
                empt = 0
            if Board[k][v].__str__() == 'r':
                fen_ret += 'r'
                empt = 0
            if Board[k][v].__str__() == 'R':
                fen_ret += 'R'
                empt = 0
            if Board[k][v].__str__() == 'q':
                fen_ret += 'q'
                empt = 0
            if Board[k][v].__str__() == 'Q':
                fen_ret += 'Q'
                empt = 0
        if k != 7:
            fen_ret += "/"
    fen_ret += " " + ("w" if move_turn == 1 else "b") + " "
    if cast[0] != 0:
        fen_ret += "K"
    if cast[1] != 0:
        fen_ret += "Q"
    if cast[2] != 0:
        fen_ret += 'k'
    if cast[3] != 0:
        fen_ret += "q"
    if cast == [0, 0, 0, 0]:
        fen_ret += "-"
    if not enpassant:
        fen_ret += " "  # сюда взятие на проходе
        fen_ret += "- "
    fen_ret += str(moves50) + " " + str(move_number)
    return fen_ret


def uci_move(classification, move):
    global move_turn
    if classification == 1:
        string = chr(ord("a") + move[1]) + str(8 - move[0]) + chr(ord("a") + move[3]) + str(8 - move[2])
        return string

    if classification == 2:
        if move_turn == 0:
            if move == "short_castle":
                return "e1g1"
            else:
                return "e1c1"
        else:
            if move == "short_castle":
                return "e8g8"
            else:
                return "e8c8"
    if classification == 3:
        string = chr(ord("a") + move[1]) + str(8 - move[0]) + chr(ord("a") + move[3]) + str(8 - move[2])
        return string
    if classification == 4:
        return move


def read_str(st):
    mas = []
    count = 0
    new_str = ''
    while count < len(st):
        if st[count] == "'":
            count += 1
            while st[count] != "'":
                new_str += st[count]
                count += 1
        count += 1
        if new_str != '':
            mas.append(new_str)
        new_str = ''
    return mas


def search():
    global start_fen, fen, filename, reached_depth
    nodes = 0
    time_for_nodes = perf_counter()
    start_fen = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1"
    fen = start_fen
    fen_get()
    got = enumeration()
    nodes += len(got)
    file = open("first.txt", "w")
    with open("first.txt", "w") as f:
        for d in range(len(got)):
            f.write(str(got[d]))
            f.write("\n")
    file.close()
    reached_depth += 1
    while reached_depth <= depth:
        file = open(filename[0], "r")
        file2 = open(filename[1], "w")
        previous = [1]
        with open(filename[1], "w") as f2:
            while previous:
                previous = read_str(file.readline())
                if previous:
                    fen = previous[1]
                    fen_get()
                    got = enumeration()
                    nodes += len(got)
                    for f in range(len(got)):
                        got[f][0] = previous[0] + " " + got[f][0]
                    for f in range(len(got)):
                        f2.write(str(got[f]))
                        f2.write("\n")
        filename = [filename[1], filename[0]]
        reached_depth += 1
        print(reached_depth)
        file.close()
        file2.close()
    time_for_nodes = perf_counter() - time_for_nodes
    remove("first.txt")
    remove("second.txt")
    return [nodes, time_for_nodes]


mas = search()
print(ceil(mas[1]))
print(str(mas[0]//mas[1]) + " positions per second")
